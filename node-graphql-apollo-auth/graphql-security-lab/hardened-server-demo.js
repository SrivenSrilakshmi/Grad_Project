#!/usr/bin/env node
/**
 * Hardened GraphQL Server Security Demonstration
 * 
 * This script demonstrates the security features of our hardened GraphQL server
 * by running various attacks and showing how they are mitigated.
 */

const fetch = require('node-fetch');
const yargs = require('yargs/yargs');
const { hideBin } = require('yargs/helpers');

// Demo configuration
const HARDENED_ENDPOINT = 'http://localhost:4001/graphql';
const VULNERABLE_ENDPOINT = 'http://localhost:4000/graphql';

// Test tokens (generated by hardened server)
const USER_TOKEN = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiIxIiwiaWF0IjoxNzYyNDc4NjQ3LCJleHAiOjE3NjI0ODIyNDd9.7_4LpRNfXcEI3InXIwGYvxg8yrBViiXY6VOgJKxlLnk';
const ADMIN_TOKEN = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiIzIiwiaWF0IjoxNzYyNDc4NjQ3LCJleHAiOjE3NjI0ODIyNDd9.gak6RsawVa-b53RJExqimIkoNq3Q9QTgwleIUZ3fYiY';

// Colors for terminal output
const colors = {
  red: '\x1b[31m',
  green: '\x1b[32m',
  yellow: '\x1b[33m',
  blue: '\x1b[34m',
  magenta: '\x1b[35m',
  cyan: '\x1b[36m',
  white: '\x1b[37m',
  reset: '\x1b[0m',
  bold: '\x1b[1m',
  dim: '\x1b[2m'
};

// Utility functions
function log(message, color = 'white') {
  console.log(`${colors[color]}${message}${colors.reset}`);
}

function header(title) {
  console.log('\n' + '='.repeat(60));
  log(`${title}`, 'bold');
  console.log('='.repeat(60));
}

function subheader(title) {
  console.log('\n' + '-'.repeat(40));
  log(`${title}`, 'cyan');
  console.log('-'.repeat(40));
}

async function makeRequest(endpoint, query, variables = {}, headers = {}) {
  try {
    const response = await fetch(endpoint, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        ...headers
      },
      body: JSON.stringify({ query, variables })
    });

    const result = await response.json();
    const duration = response.headers.get('x-response-time') || 'N/A';
    
    return {
      success: response.ok,
      status: response.status,
      data: result.data,
      errors: result.errors,
      extensions: result.extensions,
      duration,
      size: JSON.stringify(result).length
    };
  } catch (error) {
    return {
      success: false,
      error: error.message,
      status: 0
    };
  }
}

async function checkServerStatus(endpoint, name) {
  try {
    const response = await fetch(endpoint, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ query: '{ __typename }' })
    });
    
    if (response.ok) {
      log(`‚úÖ ${name} is running on ${endpoint}`, 'green');
      return true;
    } else {
      log(`‚ùå ${name} returned status ${response.status}`, 'red');
      return false;
    }
  } catch (error) {
    log(`‚ùå ${name} is not accessible: ${error.message}`, 'red');
    return false;
  }
}

async function demonstrateIntrospection() {
  subheader('1. Schema Introspection Protection');
  
  const introspectionQuery = `
    query IntrospectionQuery {
      __schema {
        types {
          name
          kind
          description
        }
      }
    }
  `;

  log('Testing introspection on vulnerable server...', 'yellow');
  const vulnerableResult = await makeRequest(VULNERABLE_ENDPOINT, introspectionQuery);
  if (vulnerableResult.success && vulnerableResult.data) {
    log(`‚úÖ Vulnerable server exposed ${vulnerableResult.data.__schema.types.length} schema types`, 'red');
    log(`üì¶ Response size: ${vulnerableResult.size} bytes`, 'dim');
  } else {
    log('‚ùå Vulnerable server introspection failed', 'yellow');
  }

  log('\nTesting introspection on hardened server...', 'yellow');
  const hardenedResult = await makeRequest(HARDENED_ENDPOINT, introspectionQuery);
  if (hardenedResult.errors && hardenedResult.errors.some(e => e.message.includes('introspection'))) {
    log('üõ°Ô∏è  Hardened server blocked introspection!', 'green');
  } else if (hardenedResult.success && hardenedResult.data) {
    log('‚ö†Ô∏è  Hardened server allowed introspection (development mode)', 'yellow');
    log(`üì¶ Response size: ${hardenedResult.size} bytes`, 'dim');
  } else {
    log('‚ùå Hardened server introspection test failed', 'red');
  }
}

async function demonstrateDepthLimit() {
  subheader('2. Query Depth Limiting');
  
  // Create a deeply nested query (depth 10)
  const deepQuery = `
    query DeepQuery {
      posts {
        author {
          posts {
            author {
              posts {
                author {
                  posts {
                    author {
                      posts {
                        author {
                          name
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  `;

  log('Testing deep query (depth 10) on vulnerable server...', 'yellow');
  const vulnerableResult = await makeRequest(VULNERABLE_ENDPOINT, deepQuery);
  if (vulnerableResult.success) {
    log('‚úÖ Vulnerable server executed deep query successfully', 'red');
    log(`üì¶ Response size: ${vulnerableResult.size} bytes`, 'dim');
  } else {
    log('‚ùå Vulnerable server rejected deep query', 'yellow');
  }

  log('\nTesting deep query (depth 10) on hardened server...', 'yellow');
  const hardenedResult = await makeRequest(HARDENED_ENDPOINT, deepQuery);
  if (hardenedResult.errors && hardenedResult.errors.some(e => e.message.includes('depth'))) {
    log('üõ°Ô∏è  Hardened server blocked deep query (depth > 7)!', 'green');
    log(`Error: ${hardenedResult.errors[0].message}`, 'dim');
  } else if (hardenedResult.success) {
    log('‚ö†Ô∏è  Hardened server allowed deep query', 'yellow');
  } else {
    log('‚ùå Hardened server depth test failed', 'red');
  }
}

async function demonstrateAuthentication() {
  subheader('3. Authentication & Authorization');
  
  const protectedQuery = `
    query ProtectedData {
      users {
        id
        name
        email
      }
    }
  `;

  const adminQuery = `
    query AdminData {
      adminStats {
        totalUsers
        totalPosts
        systemHealth
      }
    }
  `;

  // Test without authentication
  log('Testing protected query without authentication...', 'yellow');
  const noAuthResult = await makeRequest(HARDENED_ENDPOINT, protectedQuery);
  if (noAuthResult.errors && noAuthResult.errors.some(e => e.message.includes('Authentication required'))) {
    log('üõ°Ô∏è  Hardened server requires authentication!', 'green');
  } else {
    log('‚ö†Ô∏è  Query succeeded without authentication', 'yellow');
  }

  // Test with user token
  log('\nTesting protected query with user token...', 'yellow');
  const userAuthResult = await makeRequest(HARDENED_ENDPOINT, protectedQuery, {}, {
    'Authorization': `Bearer ${USER_TOKEN}`
  });
  if (userAuthResult.success && userAuthResult.data) {
    log('‚úÖ User authentication successful!', 'green');
    log(`üìä Retrieved ${userAuthResult.data.users.length} users`, 'dim');
  } else {
    log('‚ùå User authentication failed', 'red');
  }

  // Test admin query with user token (should fail)
  log('\nTesting admin query with user token (should fail)...', 'yellow');
  const userAdminResult = await makeRequest(HARDENED_ENDPOINT, adminQuery, {}, {
    'Authorization': `Bearer ${USER_TOKEN}`
  });
  if (userAdminResult.errors && userAdminResult.errors.some(e => e.message.includes('Admin access required'))) {
    log('üõ°Ô∏è  User token correctly denied admin access!', 'green');
  } else {
    log('‚ö†Ô∏è  User token was allowed admin access', 'yellow');
  }

  // Test admin query with admin token
  log('\nTesting admin query with admin token...', 'yellow');
  const adminAuthResult = await makeRequest(HARDENED_ENDPOINT, adminQuery, {}, {
    'Authorization': `Bearer ${ADMIN_TOKEN}`
  });
  if (adminAuthResult.success && adminAuthResult.data) {
    log('‚úÖ Admin authentication successful!', 'green');
    log(`üìä System health: ${adminAuthResult.data.adminStats.systemHealth}`, 'dim');
  } else {
    log('‚ùå Admin authentication failed', 'red');
  }
}

async function demonstrateInputValidation() {
  subheader('4. Input Validation & Sanitization');
  
  const maliciousInput = {
    title: '<script>alert("XSS")</script>Malicious Post',
    body: 'This post contains malicious content',
    authorId: 'invalid-id-format'
  };

  const addPostMutation = `
    mutation AddSecurePost($input: AddPostInput!) {
      secureAddPost(input: $input) {
        id
        title
        body
      }
    }
  `;

  log('Testing input validation with malicious data...', 'yellow');
  const validationResult = await makeRequest(HARDENED_ENDPOINT, addPostMutation, 
    { input: maliciousInput }, 
    { 'Authorization': `Bearer ${USER_TOKEN}` }
  );

  if (validationResult.errors) {
    log('üõ°Ô∏è  Input validation blocked malicious data!', 'green');
    log(`Error: ${validationResult.errors[0].message}`, 'dim');
  } else {
    log('‚ö†Ô∏è  Malicious input was accepted', 'yellow');
  }

  // Test with valid input
  const validInput = {
    title: 'Valid Post Title',
    body: 'This is a legitimate post',
    authorId: '1'
  };

  log('\nTesting with valid input...', 'yellow');
  const validResult = await makeRequest(HARDENED_ENDPOINT, addPostMutation,
    { input: validInput },
    { 'Authorization': `Bearer ${USER_TOKEN}` }
  );

  if (validResult.success && validResult.data) {
    log('‚úÖ Valid input accepted successfully!', 'green');
    log(`üìù Created post: "${validResult.data.secureAddPost.title}"`, 'dim');
  } else {
    log('‚ùå Valid input was rejected', 'red');
  }
}

async function demonstrateComplexityAnalysis() {
  subheader('5. Query Complexity Analysis');
  
  // Create a complex query with many fields
  const complexQuery = `
    query ComplexQuery {
      posts {
        id title body
        author { id name email }
        comments { id text author { id name } }
      }
      users {
        id name email
        posts { id title body }
      }
    }
  `;

  log('Testing complex query on hardened server...', 'yellow');
  const start = Date.now();
  const complexResult = await makeRequest(HARDENED_ENDPOINT, complexQuery);
  const duration = Date.now() - start;

  if (complexResult.success) {
    log('‚úÖ Complex query executed successfully', 'green');
    log(`‚è±Ô∏è  Execution time: ${duration}ms`, 'dim');
    log(`üì¶ Response size: ${complexResult.size} bytes`, 'dim');
  } else if (complexResult.errors && complexResult.errors.some(e => e.message.includes('complexity'))) {
    log('üõ°Ô∏è  Query complexity limit exceeded!', 'green');
    log(`Error: ${complexResult.errors[0].message}`, 'dim');
  } else {
    log('‚ùå Complex query test failed', 'red');
  }
}

async function demonstrateRateLimit() {
  subheader('6. Rate Limiting');
  
  const simpleQuery = '{ posts { id } }';
  const requests = [];
  const startTime = Date.now();

  log('Sending 10 rapid requests to test rate limiting...', 'yellow');
  
  for (let i = 0; i < 10; i++) {
    requests.push(makeRequest(HARDENED_ENDPOINT, simpleQuery));
  }

  const results = await Promise.all(requests);
  const endTime = Date.now();
  const successful = results.filter(r => r.success).length;
  const rateLimited = results.filter(r => r.status === 429).length;

  log(`üìä Results: ${successful} successful, ${rateLimited} rate limited`, 'dim');
  log(`‚è±Ô∏è  Total time: ${endTime - startTime}ms`, 'dim');

  if (rateLimited > 0) {
    log('üõ°Ô∏è  Rate limiting is active!', 'green');
  } else {
    log('‚ö†Ô∏è  No rate limiting detected (may need more requests)', 'yellow');
  }
}

async function comparePerformance() {
  subheader('7. Performance Comparison');
  
  const testQuery = `
    query PerformanceTest {
      posts {
        id
        title
        author {
          name
        }
      }
    }
  `;

  // Test vulnerable server
  log('Testing performance on vulnerable server...', 'yellow');
  const vulnStart = Date.now();
  const vulnResult = await makeRequest(VULNERABLE_ENDPOINT, testQuery);
  const vulnDuration = Date.now() - vulnStart;

  // Test hardened server
  log('Testing performance on hardened server...', 'yellow');
  const hardStart = Date.now();
  const hardResult = await makeRequest(HARDENED_ENDPOINT, testQuery);
  const hardDuration = Date.now() - hardStart;

  if (vulnResult.success && hardResult.success) {
    log(`üìä Performance Comparison:`, 'cyan');
    log(`   Vulnerable server: ${vulnDuration}ms`, 'dim');
    log(`   Hardened server: ${hardDuration}ms`, 'dim');
    
    const overhead = hardDuration - vulnDuration;
    const overheadPercent = ((overhead / vulnDuration) * 100).toFixed(1);
    
    if (overhead > 0) {
      log(`   Security overhead: +${overhead}ms (+${overheadPercent}%)`, 'yellow');
    } else {
      log(`   No measurable overhead detected`, 'green');
    }
  } else {
    log('‚ùå Performance comparison failed', 'red');
  }
}

async function runFullDemo() {
  header('üõ°Ô∏è  HARDENED GRAPHQL SERVER SECURITY DEMONSTRATION');
  
  log('This demo shows the security features of our hardened GraphQL server', 'cyan');
  log('compared to a vulnerable implementation.\n', 'cyan');

  // Check server status
  log('Checking server availability...', 'yellow');
  const hardenedOnline = await checkServerStatus(HARDENED_ENDPOINT, 'Hardened Server');
  const vulnerableOnline = await checkServerStatus(VULNERABLE_ENDPOINT, 'Vulnerable Server');

  if (!hardenedOnline) {
    log('\n‚ùå Hardened server is not running. Please start it first:', 'red');
    log('   cd graphql-security-lab', 'dim');
    log('   node servers/hardened/src/index.js', 'dim');
    return;
  }

  // Run demonstrations
  await demonstrateIntrospection();
  await demonstrateDepthLimit();
  await demonstrateAuthentication();
  await demonstrateInputValidation();
  await demonstrateComplexityAnalysis();
  await demonstrateRateLimit();
  
  if (vulnerableOnline) {
    await comparePerformance();
  }

  // Summary
  header('üìä DEMO SUMMARY');
  log('The hardened GraphQL server demonstrated the following security controls:', 'green');
  log('‚úÖ Schema introspection protection', 'dim');
  log('‚úÖ Query depth limiting (max 7 levels)', 'dim');
  log('‚úÖ Authentication & authorization', 'dim');
  log('‚úÖ Input validation & sanitization', 'dim');
  log('‚úÖ Query complexity analysis', 'dim');
  log('‚úÖ Rate limiting', 'dim');
  log('‚úÖ Enhanced error handling', 'dim');
  
  log('\nüéØ Next steps:', 'cyan');
  log('‚Ä¢ Test with your own GraphQL queries', 'dim');
  log('‚Ä¢ Modify security settings and observe changes', 'dim');
  log('‚Ä¢ Run attack scripts against both servers for comparison', 'dim');
  log('‚Ä¢ Review the source code to understand implementation', 'dim');
}

// CLI setup
const argv = yargs(hideBin(process.argv))
  .command('full', 'Run the complete security demonstration')
  .command('introspection', 'Demo introspection protection')
  .command('depth', 'Demo query depth limiting')
  .command('auth', 'Demo authentication & authorization')
  .command('validation', 'Demo input validation')
  .command('complexity', 'Demo query complexity analysis')
  .command('ratelimit', 'Demo rate limiting')
  .command('performance', 'Compare performance between servers')
  .option('endpoint', {
    alias: 'e',
    describe: 'Hardened server endpoint',
    default: HARDENED_ENDPOINT
  })
  .help()
  .argv;

// Main execution
async function main() {
  const command = argv._[0] || 'full';
  
  switch (command) {
    case 'introspection':
      await demonstrateIntrospection();
      break;
    case 'depth':
      await demonstrateDepthLimit();
      break;
    case 'auth':
      await demonstrateAuthentication();
      break;
    case 'validation':
      await demonstrateInputValidation();
      break;
    case 'complexity':
      await demonstrateComplexityAnalysis();
      break;
    case 'ratelimit':
      await demonstrateRateLimit();
      break;
    case 'performance':
      await comparePerformance();
      break;
    case 'full':
    default:
      await runFullDemo();
      break;
  }
}

if (require.main === module) {
  main().catch(error => {
    console.error('Demo failed:', error.message);
    process.exit(1);
  });
}

module.exports = {
  makeRequest,
  demonstrateIntrospection,
  demonstrateDepthLimit,
  demonstrateAuthentication,
  demonstrateInputValidation,
  demonstrateComplexityAnalysis,
  demonstrateRateLimit
};